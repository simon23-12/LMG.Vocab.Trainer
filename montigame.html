<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monti Flug - LMG Vokabeltrainer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%);
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #intro-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white; /* Wei√üer Hintergrund */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: all;
        }

        #intro-screen .logo {
            margin-bottom: 30px;
        }

        #intro-screen .logo img {
            height: 120px;
            filter: drop-shadow(3px 3px 5px rgba(0, 0, 0, 0.2));
        }

        #intro-screen h1 {
            font-size: 48px;
            margin-bottom: 30px;
            color: #FFB700;
            text-shadow: 3px 3px 0px #0066CC;
            display: none; /* Verstecke alten Titel */
        }

        #intro-screen .rules {
            background: #0066CC; /* LMG Blau */
            padding: 30px;
            border-radius: 20px;
            max-width: 700px;
            margin-bottom: 30px;
            border: 3px solid #FFB700;
            color: white;
        }

        #intro-screen .rules h2 {
            color: #FFB700;
            margin-bottom: 15px;
        }

        #intro-screen .rules p {
            font-size: 18px;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        #intro-screen .start-hint {
            font-size: 24px;
            animation: pulse 1.5s infinite;
            color: #0066CC;
            font-weight: bold;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }

        #countdown-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 100, 200, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            pointer-events: all;
        }

        #countdown-screen .countdown-number {
            font-size: 150px;
            font-weight: bold;
            color: #FFB700;
            text-shadow: 5px 5px 0px #0066CC;
            animation: countdownPop 0.5s ease-out;
        }

        @keyframes countdownPop {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        #game-ui {
            display: none;
        }

        #altitude-meter {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 100, 200, 0.8);
            color: white;
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #FFB700;
            min-width: 150px;
            text-align: center;
        }

        #altitude-meter .label {
            font-size: 14px;
            margin-bottom: 5px;
        }

        #altitude-meter .value {
            font-size: 36px;
            font-weight: bold;
            color: #FFB700;
        }

        #altitude-meter .unit {
            font-size: 18px;
        }

        #highscore-display {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 30px; /* Noch mehr Abstand */
        }

        #highscore-display img {
            height: 60px;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
        }

        #highscore-display .value {
            font-size: 36px;
            font-weight: bold;
            color: #FFB700;
            text-shadow: 2px 2px 0px #0066CC;
            font-family: 'Comic Sans MS', Arial, sans-serif;
            min-width: 80px; /* Mehr Mindestbreite */
            padding-left: 10px; /* Extra Padding */
        }

        #score-display {
            position: absolute;
            top: 100px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 40px; /* Viel mehr Abstand */
        }

        #score-display img {
            height: 80px;
            filter: drop-shadow(3px 3px 5px rgba(0, 0, 0, 0.3));
        }

        #score-display .value {
            font-size: 48px;
            font-weight: bold;
            color: #FFB700;
            text-shadow: 3px 3px 0px #0066CC;
            font-family: 'Comic Sans MS', Arial, sans-serif;
            min-width: 100px; /* Mehr Mindestbreite */
            padding-left: 15px; /* Extra Padding */
        }

        #vocab-input-container {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 30px;
            border-radius: 15px;
            border: 3px solid #0066CC;
            min-width: 400px;
        }

        #vocab-question {
            font-size: 24px;
            color: #0066CC;
            margin-bottom: 10px;
            text-align: center;
            font-weight: bold;
        }

        #vocab-input {
            width: 100%;
            padding: 15px;
            font-size: 20px;
            border: 2px solid #0066CC;
            border-radius: 10px;
            text-align: center;
            font-family: 'Comic Sans MS', Arial, sans-serif;
            margin-bottom: 10px;
        }

        #vocab-input:focus {
            outline: none;
            border-color: #FFB700;
            box-shadow: 0 0 10px rgba(255, 183, 0, 0.5);
        }

        #timer-bar-container {
            width: 100%;
            height: 8px;
            background: #ddd;
            border-radius: 4px;
            overflow: hidden;
        }

        #timer-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #00FF00, #FFB700, #FF0000);
            transition: width 0.1s linear;
        }

        #feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            display: none;
            text-shadow: 3px 3px 0px rgba(0, 0, 0, 0.3);
            animation: feedbackPop 0.5s ease-out;
        }

        #feedback.correct {
            color: #00FF00;
        }

        #feedback.wrong {
            color: #FF0000;
        }

        @keyframes feedbackPop {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 100, 200, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            pointer-events: all;
        }

        #game-over-screen h1 {
            font-size: 60px;
            margin-bottom: 30px;
            color: #FFB700;
            text-shadow: 3px 3px 0px #0066CC;
        }

        #game-over-screen .final-score {
            font-size: 36px;
            margin-bottom: 30px;
        }

        #game-over-screen button {
            padding: 15px 40px;
            font-size: 24px;
            background: #FFB700;
            color: #0066CC;
            border: 3px solid #0066CC;
            border-radius: 15px;
            cursor: pointer;
            font-family: 'Comic Sans MS', Arial, sans-serif;
            font-weight: bold;
        }

        #game-over-screen button:hover {
            background: #FFC700;
            transform: scale(1.05);
        }
        @keyframes popupBurst {
            0% { 
                transform: translate(-50%, -50%) scale(0); 
                opacity: 0; 
            }
            30% { 
                transform: translate(-50%, -50%) scale(1.3); 
                opacity: 1; 
            }
            60% {
                transform: translate(-50%, -60%) scale(1);
                opacity: 1;
            }
            100% { 
                transform: translate(-50%, -80%) scale(0.5); 
                opacity: 0; 
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-overlay">
        <!-- Intro Screen -->
        <div id="intro-screen">
            <div class="logo">
                <img src="https://raw.githubusercontent.com/simon23-12/LMG.Vocab.Trainer/main/images/montiwhite.png" alt="Monti Flug">
            </div>
            <div class="rules">
                <h2>Spielregeln:</h2>
                <p>üéØ Halte Monti, unseren Montessori Vogel, in der Luft durch richtiges Eingeben von Vokabeln!</p>
                <p>üìö Es kommen zuf√§llig Vokabeln aller Seiten dran, die du bisher ge√ºbt hast</p>
                <p>üí• Bei 0 Meter landet Monti und das Spiel endet</p>
                <p>üèÜ Schaffst du heute einen neuen Highscore?</p>
            </div>
            <div class="start-hint">Dr√ºcke ENTER zum Starten!</div>
            <button onclick="window.location.href='display.html'" style="margin-top: 20px; background: #0066CC; color: white; border: none; padding: 12px 30px; border-radius: 10px; font-size: 18px; cursor: pointer; font-family: 'Comic Sans MS', Arial, sans-serif;">
                ‚Üê Zur√ºck zum Men√º
            </button>
        </div>

        <!-- Countdown Screen -->
        <div id="countdown-screen">
            <div class="countdown-number" id="countdown-number">3</div>
        </div>

        <!-- Game UI -->
        <div id="game-ui">
            <div id="highscore-display">
                <img src="https://raw.githubusercontent.com/simon23-12/LMG.Vocab.Trainer/main/images/highscore.png" alt="Highscore">
                <div class="value" id="highscore-value">0</div>
            </div>

            <div id="score-display">
                <img src="https://raw.githubusercontent.com/simon23-12/LMG.Vocab.Trainer/main/images/score.png" alt="Score">
                <div class="value" id="score-value">0</div>
            </div>

            <div id="altitude-meter">
                <div class="label">H√ñHE</div>
                <div class="value" id="altitude-value">100</div>
                <div class="unit">m</div>
            </div>

            <div id="vocab-input-container">
                <div id="vocab-question">test</div>
                <input type="text" id="vocab-input" autocomplete="off" placeholder="√úbersetzung eingeben...">
                <div id="timer-bar-container">
                    <div id="timer-bar"></div>
                </div>
            </div>

            <div id="feedback"></div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen">
            <h1>Monti ist gelandet! üõ¨</h1>
            <div class="final-score">Dein Score: <span id="final-score-value">0</span></div>
            <button onclick="location.reload()">Nochmal spielen</button>
            <button onclick="window.location.href='display.html'" style="background: #0066CC; margin-top: 10px;">Zur√ºck zum Men√º</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        const gameState = {
            altitude: 100,
            score: 0,
            isPlaying: false,
            isPaused: false
        };

        // Firebase Config (gleich wie in display.html)
        const firebaseConfig = {
            apiKey: "AIzaSyBRPlWh1slILKg8DWQDOEWXSFsnUK3j1vw",
            authDomain: "testdatabase-4daf4.firebaseapp.com",
            databaseURL: "https://testdatabase-4daf4-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "testdatabase-4daf4",
            storageBucket: "testdatabase-4daf4.firebasestorage.app",
            messagingSenderId: "743231387214",
            appId: "1:743231387214:web:166169b25f72616280351f"
        };

        // User & Vocabulary data
        let currentUser = null;
        let userPerformance = {};
        let availableVocabs = []; // Vokabeln von ge√ºbten Seiten
        let currentVocab = null;
        let usedVocabs = []; // Bereits gespielte Vokabeln in dieser Session

        // Lade User-Daten und Vokabeln
        async function loadUserAndVocabs() {
            try {
                // Lade User aus localStorage
                const savedUser = localStorage.getItem('lmg_currentUser');
                const savedPerformance = localStorage.getItem('lmg_userPerformance');
                
                if (!savedUser) {
                    alert('Bitte logge dich zuerst ein!');
                    window.location.href = 'index.html';
                    return false;
                }
                
                currentUser = JSON.parse(savedUser);
                userPerformance = savedPerformance ? JSON.parse(savedPerformance) : {};
                
                console.log('‚úì User geladen:', currentUser.name);
                console.log('‚úì Performance:', userPerformance);
                
                // Finde alle ge√ºbten Seiten
                const practicedPages = Object.keys(userPerformance).map(key => {
                    const match = key.match(/^page_(\d+)$/);
                    return match ? parseInt(match[1]) : null;
                }).filter(p => p !== null);
                
                console.log('‚úì Ge√ºbte Seiten:', practicedPages);
                
                if (practicedPages.length === 0) {
                    alert('Du hast noch keine Seiten ge√ºbt! √úbe zuerst ein paar Seiten, bevor du das Monti Game spielst.');
                    window.location.href = 'display.html';
                    return false;
                }
                
                // Lade Vokabeln EINMAL von GitHub
                try {
                    const className = currentUser.class || 'class5';
                    
                    console.log('üîç className:', className);
                    
                    // Mappe Klassennamen zu Dateinamen
                    let vocabFile;
                    if (className === 'class5a' || className === 'class5b' || className === 'class5') {
                        vocabFile = 'voc5_4.json';
                    } else {
                        // F√ºr andere Klassen: class6 -> voc6_4.json
                        vocabFile = `voc${className.replace('class', '')}_4.json`;
                    }
                    
                    console.log('üîç vocabFile:', vocabFile);
                    
                    const url = `https://raw.githubusercontent.com/simon23-12/LMG.Vokabeltrainer/refs/heads/main/vocab/english/${vocabFile}`;
                    
                    console.log('üì• Lade Vokabeln von:', url);
                    
                    const response = await fetch(url);
                    const text = await response.text();
                    const allVocabs = JSON.parse(text);
                    
                    console.log('‚úì JSON geladen, insgesamt', allVocabs.length, 'Vokabeln');
                    
                    // Filtere nur Vokabeln von ge√ºbten Seiten
                    availableVocabs = allVocabs.filter(v => practicedPages.includes(v.page));
                    
                    console.log('‚úì Gefilterte Vokabeln von ge√ºbten Seiten:', availableVocabs.length);
                    console.log('‚úì Beispiel-Vokabel:', availableVocabs[0]);
                    
                } catch (error) {
                    console.error('Fehler beim Laden der Vokabeln:', error);
                    alert('Fehler beim Laden der Vokabeln!');
                    window.location.href = 'display.html';
                    return false;
                }
                
                if (availableVocabs.length === 0) {
                    alert('Keine Vokabeln gefunden!');
                    window.location.href = 'display.html';
                    return false;
                }
                
                return true;
            } catch (error) {
                console.error('Fehler beim Laden:', error);
                alert('Fehler beim Laden der Daten!');
                window.location.href = 'display.html';
                return false;
            }
        }

        // W√§hle zuf√§llige neue Vokabel
        function selectRandomVocab() {
            // Filtere bereits verwendete Vokabeln raus
            const unused = availableVocabs.filter(v => 
                !usedVocabs.some(used => used.english === v.english)
            );
            
            // Wenn alle verwendet wurden, reset
            if (unused.length === 0) {
                console.log('Alle Vokabeln gespielt, reset!');
                usedVocabs = [];
                return selectRandomVocab();
            }
            
            // W√§hle zuf√§llige Vokabel
            const randomVocab = unused[Math.floor(Math.random() * unused.length)];
            usedVocabs.push(randomVocab);
            
            currentVocab = {
                question: randomVocab.german, // Frage ist auf Deutsch
                answers: [randomVocab.english, ...(randomVocab.synonyms || [])] // Antworten sind Englisch + Synonyme
            };
            
            console.log('Neue Vokabel:', currentVocab);
            
            // Update UI
            document.getElementById('vocab-question').textContent = currentVocab.question;
        }

        // Three.js Setup
        let scene, camera, renderer, monti;
        let altitudeDelta = 0; // F√ºr smooth altitude changes

        function initThreeJS() {
            const canvas = document.getElementById('gameCanvas');
            scene = new THREE.Scene();
            
            // Camera - from behind and slightly above
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5.5, 10); // H√∂her f√ºr bessere Sicht auf Monti
            camera.lookAt(0, 3.5, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB, 1);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            // Create Monti the Bird
            createMonti();
            
            // Mache Monti zu einem Kind der Kamera, damit er immer im Viewport bleibt
            camera.add(monti);
            monti.position.set(0, 0.2, -8); // Noch h√∂her: 0.2
            
            // F√ºge Kamera zur Scene hinzu (wichtig f√ºr Children)
            scene.add(camera);

            // Create Clouds
            createClouds();

            // Create Landscape
            createLandscape();

            // Window resize handler
            window.addEventListener('resize', onWindowResize);
        }

        function createMonti() {
            monti = new THREE.Group();

            // Body (Yellow center - LMG Gelb) - 30% kleiner
            const bodyGeometry = new THREE.SphereGeometry(0.28, 32, 32); // 0.28 statt 0.4 (30% kleiner)
            const bodyMaterial = new THREE.MeshToonMaterial({ color: 0xFFB700 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = -0.5;
            monti.add(body);
            monti.body = body; // Speichere Referenz f√ºr Animation

            // Create detailed wings with LMG color gradient
            const leftWing = createDetailedWing();
            leftWing.position.set(-0.5, 0, -0.15);
            leftWing.rotation.y = Math.PI * 0.3;
            leftWing.rotation.z = -Math.PI * 0.3; // Ausgebreitet
            leftWing.rotation.x = -0.1;
            monti.add(leftWing);
            monti.leftWing = leftWing;

            const rightWing = createDetailedWing();
            rightWing.scale.x = -1; // Mirror
            rightWing.position.set(0.5, 0, -0.15);
            rightWing.rotation.y = -Math.PI * 0.3;
            rightWing.rotation.z = Math.PI * 0.3; // Ausgebreitet
            rightWing.rotation.x = -0.1;
            monti.add(rightWing);
            monti.rightWing = rightWing;

            // KEINE Schwanzfedern mehr!

            monti.rotation.x = -0.1; // Slight forward tilt
            // Position wird √ºber camera.add() gesetzt
        }

        function createDetailedWing() {
            const wing = new THREE.Group();
            
            // Wing structure: Nur √§u√üere Federn - keine inneren gelben/hellblauen mehr
            const featherLayers = [
                // Outer feathers (tips) - Navy blue
                { color: 0x000080, length: 3.0, width: 0.18, count: 5, startAngle: 0, spread: 0.6 },
                // Mid-outer - LMG Blue
                { color: 0x0066CC, length: 2.8, width: 0.2, count: 5, startAngle: 0.1, spread: 0.5 },
                // Mid - Steel Blue
                { color: 0x4682B4, length: 2.6, width: 0.22, count: 5, startAngle: 0.2, spread: 0.45 },
                // Mid-inner - Cyan
                { color: 0x00CED1, length: 2.4, width: 0.24, count: 5, startAngle: 0.3, spread: 0.4 }
                // ENTFERNT: Aquamarine und Gold Layer die oben sichtbar waren
            ];

            featherLayers.forEach((layer, layerIndex) => {
                for (let i = 0; i < layer.count; i++) {
                    const featherGeometry = new THREE.BoxGeometry(layer.width, layer.length, 0.05);
                    const featherMaterial = new THREE.MeshToonMaterial({ color: layer.color });
                    const feather = new THREE.Mesh(featherGeometry, featherMaterial);
                    
                    const angle = layer.startAngle + (i / layer.count) * layer.spread;
                    const radius = 1.2 + layerIndex * 0.15;
                    
                    feather.position.x = Math.sin(angle) * radius;
                    feather.position.y = -Math.cos(angle) * radius * 0.5;
                    feather.position.z = layerIndex * 0.02;
                    feather.rotation.z = angle - Math.PI / 2;
                    
                    wing.add(feather);
                }
            });

            return wing;
        }

        function createClouds() {
            // Clouds above (at 200m+ altitude)
            const cloudGeometry = new THREE.SphereGeometry(1, 16, 16);
            const cloudMaterial = new THREE.MeshToonMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.9 
            });

            window.clouds = []; // Array f√ºr Wolken-Referenzen

            for (let i = 0; i < 15; i++) {
                const cloud = new THREE.Group();
                
                // Multiple spheres for cloud shape
                for (let j = 0; j < 6; j++) {
                    const cloudPart = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    cloudPart.scale.set(
                        Math.random() * 0.8 + 0.6,
                        Math.random() * 0.4 + 0.3,
                        Math.random() * 0.8 + 0.6
                    );
                    cloudPart.position.set(
                        Math.random() * 2.5 - 1.25,
                        Math.random() * 0.8,
                        Math.random() * 2.5 - 1.25
                    );
                    cloud.add(cloudPart);
                }

                cloud.position.set(
                    Math.random() * 60 - 30,
                    20 + Math.random() * 5,  // High up for 200m altitude
                    Math.random() * 60 - 80
                );
                
                scene.add(cloud);
                window.clouds.push(cloud); // Speichere Referenz
            }
        }

        // Create scrolling landscape below
        let landscapeSegments = [];
        
        function createLandscape() {
            // Erstelle 3 Landschafts-Segmente f√ºr nahtloses Loop - NOCH GR√ñSSER
            for (let seg = 0; seg < 3; seg++) {
                const segment = new THREE.Group();
                const zOffset = seg * 800 - 800; // Noch l√§nger: 800 statt 500
                
                // Ground plane (grass) - NOCH GR√ñSSER
                const groundGeometry = new THREE.PlaneGeometry(600, 800); // 600x800 statt 400x500
                const groundMaterial = new THREE.MeshToonMaterial({ 
                    color: 0x7CFC00,  // Lawn green
                    side: THREE.DoubleSide 
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -15;
                ground.position.z = 0; // Relativ zum Segment
                segment.add(ground);
                
                // Add texture variation with darker green patches - NOCH MEHR Patches
                for (let i = 0; i < 100; i++) { // 100 statt 60
                    const patchGeometry = new THREE.CircleGeometry(Math.random() * 4 + 2, 16);
                    const patchMaterial = new THREE.MeshToonMaterial({ 
                        color: 0x228B22,  // Forest green
                        side: THREE.DoubleSide 
                    });
                    const patch = new THREE.Mesh(patchGeometry, patchMaterial);
                    patch.rotation.x = -Math.PI / 2;
                    patch.position.set(
                        Math.random() * 580 - 290, // Breiter verteilt
                        -14.9,
                        Math.random() * 780 - 390  // L√§nger verteilt
                    );
                    segment.add(patch);
                }
                
                // Lakes/ponds - NOCH MEHR Seen
                for (let i = 0; i < 25; i++) { // 25 statt 15
                    const lakeGeometry = new THREE.CircleGeometry(Math.random() * 10 + 5, 16);
                    const lakeMaterial = new THREE.MeshToonMaterial({ 
                        color: 0x1E90FF,  // Dodger blue
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.8
                    });
                    const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
                    lake.rotation.x = -Math.PI / 2;
                    lake.position.set(
                        Math.random() * 560 - 280, // Breiter
                        -14.8,
                        Math.random() * 760 - 380  // L√§nger
                    );
                    segment.add(lake);
                }
                
                // Trees - NOCH VIEL MEHR B√§ume
                for (let i = 0; i < 150; i++) { // 150 statt 100
                    const tree = createTree();
                    tree.position.set(
                        Math.random() * 580 - 290, // Breiter
                        -15,
                        Math.random() * 780 - 390  // L√§nger
                    );
                    segment.add(tree);
                }
                
                // Berge links und rechts F√úR JEDES SEGMENT - NOCH MEHR und NOCH WEITER AU√üEN
                // Linke Berge
                for (let i = 0; i < 8; i++) { // 8 statt 6
                    const mountain = createMountain();
                    mountain.position.set(
                        -220 - (Math.random() * 80), // Noch weiter links
                        -12,
                        Math.random() * 780 - 390
                    );
                    segment.add(mountain);
                }
                
                // Rechte Berge
                for (let i = 0; i < 8; i++) { // 8 statt 6
                    const mountain = createMountain();
                    mountain.position.set(
                        220 + (Math.random() * 80), // Noch weiter rechts
                        -12,
                        Math.random() * 780 - 390
                    );
                    segment.add(mountain);
                }
                
                segment.position.z = zOffset;
                landscapeSegments.push(segment);
                scene.add(segment);
            }
        }
        
        function createMountain() {
            const mountainPart = new THREE.Group();
            
            const mountainHeight = Math.random() * 20 + 25;
            const mountainWidth = Math.random() * 10 + 12;
            
            // Hauptkegel mit mehreren Segmenten f√ºr Textur
            const mainPeakGeometry = new THREE.ConeGeometry(
                mountainWidth,
                mountainHeight,
                6,
                8
            );
            
            const grayValue = Math.random() * 0.2 + 0.35; // 0.35-0.55
            const mountainColor = new THREE.Color(grayValue, grayValue, grayValue);
            const mainPeakMaterial = new THREE.MeshToonMaterial({ 
                color: mountainColor,
                flatShading: true
            });
            const mainPeak = new THREE.Mesh(mainPeakGeometry, mainPeakMaterial);
            mainPeak.rotation.z = (Math.random() - 0.5) * 0.2;
            mountainPart.add(mainPeak);
            
            // 1-2 Nebengipfel f√ºr Unregelm√§√üigkeit
            const sideCount = Math.random() > 0.5 ? 2 : 1;
            for (let j = 0; j < sideCount; j++) {
                const sidePeakGeometry = new THREE.ConeGeometry(
                    mountainWidth * 0.5,
                    mountainHeight * 0.65,
                    5,
                    6
                );
                const sidePeak = new THREE.Mesh(sidePeakGeometry, mainPeakMaterial);
                sidePeak.position.x = (j === 0 ? -1 : 1) * mountainWidth * 0.6;
                sidePeak.position.y = -mountainHeight * 0.25;
                sidePeak.rotation.z = (Math.random() - 0.5) * 0.3;
                mountainPart.add(sidePeak);
            }
            
            // Schneekappe - KLEINER als der Berg
            const snowCapGeometry = new THREE.ConeGeometry(
                mountainWidth * 0.25,  // Viel kleiner!
                mountainHeight * 0.2,  // Nur 20% der Bergh√∂he
                6,
                3
            );
            const snowCapMaterial = new THREE.MeshToonMaterial({ 
                color: 0xFFFAFA,
                flatShading: true
            });
            const snowCap = new THREE.Mesh(snowCapGeometry, snowCapMaterial);
            snowCap.position.y = mountainHeight * 0.4;  // Oben auf dem Berg
            snowCap.rotation.z = mainPeak.rotation.z;
            mountainPart.add(snowCap);
            
            return mountainPart;
        }
        
        function createTree() {
            const tree = new THREE.Group();
            
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
            const trunkMaterial = new THREE.MeshToonMaterial({ color: 0x8B4513 }); // Saddle brown
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 1;
            tree.add(trunk);
            
            // Foliage (cone-shaped)
            const foliageGeometry = new THREE.ConeGeometry(1.5, 3, 8);
            const foliageMaterial = new THREE.MeshToonMaterial({ color: 0x228B22 }); // Forest green
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = 3;
            tree.add(foliage);
            
            return tree;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation
        let wingFlapTime = 0;
        let bobTime = 0;
        const landscapeScrollSpeed = 0.3;
        let isFlapping = false;
        let flapDuration = 0;
        let isFalling = false;
        let fallDuration = 0;
        let fallTime = 0;

        function animate() {
            requestAnimationFrame(animate);

            if (monti) {
                if (isFalling) {
                    // Fall-Animation bei falscher Antwort
                    fallTime += 0.016;
                    
                    // Fl√ºgel klappen zusammen
                    const collapseAngle = Math.min(fallTime * 2, 1) * (Math.PI * 0.4);
                    monti.leftWing.rotation.z = -Math.PI * 0.25 - collapseAngle;
                    monti.rightWing.rotation.z = Math.PI * 0.25 + collapseAngle;
                    
                    // K√∂rper taumelt
                    monti.rotation.x = -0.1 + Math.sin(fallTime * 10) * 0.2;
                    monti.rotation.z = Math.sin(fallTime * 8) * 0.15;
                    
                    // K√∂rper vibriert
                    const shake = Math.sin(fallTime * 20) * 0.05;
                    monti.body.position.y = -0.5 + shake;
                    
                    fallDuration -= 0.016;
                    if (fallDuration <= 0) {
                        isFalling = false;
                        // Reset zu Gleitflug-Position
                        monti.leftWing.rotation.z = -Math.PI * 0.25;
                        monti.rightWing.rotation.z = Math.PI * 0.25;
                        monti.body.position.y = -0.5;
                        monti.rotation.x = -0.1;
                        monti.rotation.z = 0;
                    }
                } else if (isFlapping) {
                    // Aktiver Fl√ºgelschlag bei richtigen Antworten
                    wingFlapTime += 0.25;
                    const flapAngle = Math.sin(wingFlapTime) * 0.4;
                    monti.leftWing.rotation.z = -Math.PI * 0.25 + flapAngle;
                    monti.rightWing.rotation.z = Math.PI * 0.25 - flapAngle;
                    
                    // K√∂rper-Animation beim Flattern
                    const bodyBounce = Math.abs(Math.sin(wingFlapTime)) * 0.08;
                    monti.body.position.y = -0.5 + bodyBounce;
                    
                    // Leichte Rotationsbewegung des ganzen Vogels
                    monti.rotation.x = -0.1 + Math.sin(wingFlapTime) * 0.05;
                    
                    flapDuration -= 0.016; // ca. 60fps
                    if (flapDuration <= 0) {
                        isFlapping = false;
                        // Reset zu Gleitflug-Position
                        monti.leftWing.rotation.z = -Math.PI * 0.25;
                        monti.rightWing.rotation.z = Math.PI * 0.25;
                        monti.body.position.y = -0.5;
                        monti.rotation.x = -0.1;
                    }
                } else {
                    // Sanftes Gleiten - minimal wing adjustment
                    wingFlapTime += 0.02;
                    const glideAngle = Math.sin(wingFlapTime) * 0.05;
                    monti.leftWing.rotation.z = -Math.PI * 0.25 + glideAngle;
                    monti.rightWing.rotation.z = Math.PI * 0.25 - glideAngle;
                    
                    // Subtile K√∂rperbewegung auch beim Gleiten
                    const subtleBodyMove = Math.sin(wingFlapTime * 0.5) * 0.01;
                    monti.body.position.y = -0.5 + subtleBodyMove;
                }

                // Sehr subtiles bobbing - relativ zur Kamera-Position (nur wenn nicht fallend)
                if (!isFalling) {
                    bobTime += 0.02;
                    const bobbingOffset = Math.sin(bobTime) * 0.03;
                    monti.position.y = 0.2 + bobbingOffset;
                }

                // KEINE Kamera-Bewegung mehr - die Welt bewegt sich stattdessen!
                // altitudeDelta wird nicht mehr benutzt
            }

            // Animiere H√∂hen-Anzeige
            if (displayedAltitude !== targetAltitude) {
                const diff = targetAltitude - displayedAltitude;
                const step = diff > 0 ? 
                    Math.min(Math.abs(diff), 2) : // +10 in ~5 frames (schnell hoch)
                    -Math.min(Math.abs(diff), 10); // -50 in ~5 frames (schnell runter)
                
                displayedAltitude += step;
                
                // Wenn nah genug am Ziel, setze direkt
                if (Math.abs(targetAltitude - displayedAltitude) < 1) {
                    displayedAltitude = targetAltitude;
                }
                
                document.getElementById('altitude-value').textContent = Math.max(0, Math.round(displayedAltitude));
            }

            // Scroll landscape segments towards camera
            if (landscapeSegments.length > 0 && gameState.isPlaying) {
                landscapeSegments.forEach(segment => {
                    segment.position.z += landscapeScrollSpeed;
                    
                    // Wenn Segment hinter Kamera, teleportiere es nach vorne
                    if (segment.position.z > 1200) { // 1200 (3 * 800 / 2)
                        segment.position.z -= 2400; // 2400 (3 * 800)
                    }
                    
                    // Bewege Landschaft basierend auf H√∂he
                    // Bei 0m: Landschaft bei Y=0 (Monti ist direkt am Boden!)
                    // Bei 200m: Landschaft bei Y=-200 (weit unten)
                    const altitudeOffset = -gameState.altitude;
                    segment.position.y = 0 + altitudeOffset;
                });
            }

            // Bewege Wolken basierend auf H√∂he
            if (window.clouds && gameState.isPlaying) {
                const altitudeOffset = -gameState.altitude;
                // Wolken m√ºssen bei 140m altitude auf Monti-H√∂he sein
                // originalY ist ca. 20-25
                // Bei 0m: Y = 160 (hoch oben)
                // Bei 140m: Y = 20 (bei Monti)
                window.clouds.forEach(cloud => {
                    // Speichere urspr√ºngliche Y wenn nicht vorhanden
                    if (cloud.userData.originalY === undefined) {
                        cloud.userData.originalY = cloud.position.y;
                    }
                    // Wolken starten 140m √ºber ihrer Original-Position
                    cloud.position.y = cloud.userData.originalY + 140 + altitudeOffset;
                });
            }

            renderer.render(scene, camera);
        }

        function triggerWingFlap() {
            isFlapping = true;
            flapDuration = 0.8; // 0.8 Sekunden Fl√ºgelschlag
            wingFlapTime = 0;
        }

        function triggerFall() {
            isFalling = true;
            fallDuration = 1.0; // 1 Sekunde Fall-Animation
            fallTime = 0;
        }

        // Game Logic
        let gameInterval;
        let targetAltitude = 100; // Ziel-H√∂he f√ºr Animation
        let displayedAltitude = 100; // Angezeigte H√∂he
        let vocabTimer = null;
        let vocabTimeLeft = 15;

        function startGame() {
            gameState.isPlaying = true;
            gameState.altitude = 100;
            targetAltitude = 100;
            displayedAltitude = 100;
            gameState.score = 0;
            
            document.getElementById('game-ui').style.display = 'block';
            document.getElementById('vocab-input').focus();
            
            updateUI();
            startVocabTimer();
            
            // Altitude decrease interval
            gameInterval = setInterval(() => {
                if (!gameState.isPaused) {
                    gameState.altitude -= 2; // 2 Meter pro Sekunde
                    targetAltitude = gameState.altitude;
                    updateUI();
                    
                    if (gameState.altitude <= 0) {
                        endGame();
                    }
                }
            }, 1000);
        }

        function startVocabTimer() {
            vocabTimeLeft = 15;
            updateTimerBar();
            
            if (vocabTimer) clearInterval(vocabTimer);
            
            vocabTimer = setInterval(() => {
                vocabTimeLeft -= 0.1;
                updateTimerBar();
                
                if (vocabTimeLeft <= 0) {
                    // Zeit abgelaufen - z√§hlt als falsche Antwort
                    clearInterval(vocabTimer);
                    handleTimeout();
                }
            }, 100);
        }

        function updateTimerBar() {
            const percentage = (vocabTimeLeft / 15) * 100;
            document.getElementById('timer-bar').style.width = percentage + '%';
        }

        function handleTimeout() {
            // Zeit abgelaufen - behandle wie falsche Antwort
            const newAltitude = Math.max(gameState.altitude - 50, 0);
            gameState.altitude = newAltitude;
            targetAltitude = newAltitude;
            
            triggerFall();
            showPointsPopup('-50 Meter', false);
            showFeedback('Zeit abgelaufen! ‚úó', false);
            updateUI();
            
            document.getElementById('vocab-input').value = '';
            
            if (gameState.altitude <= 0) {
                setTimeout(() => {
                    endGame();
                }, 1000);
            } else {
                // W√§hle neue Vokabel
                selectRandomVocab();
                
                startVocabTimer(); // Neuer Timer f√ºr n√§chste Vokabel
            }
        }

        function updateUI() {
            // Score wird direkt aktualisiert
            document.getElementById('score-value').textContent = gameState.score;
            // H√∂he wird animiert in animate() aktualisiert
        }

        function checkAnswer(answer) {
            const normalizedAnswer = answer.trim().toLowerCase();
            const correctAnswers = currentVocab.answers.map(a => a.toLowerCase());
            
            if (correctAnswers.includes(normalizedAnswer)) {
                // Correct!
                clearInterval(vocabTimer); // Stop timer
                
                const newAltitude = Math.min(gameState.altitude + 10, 200); // Max 200m
                gameState.altitude = newAltitude;
                targetAltitude = newAltitude;
                gameState.score += 10;
                
                // Trigger wing flapping animation
                triggerWingFlap();
                
                // Show +10 Meter popup
                showPointsPopup('+10 Meter', true);
                
                showFeedback('Richtig! ‚úì', true);
                updateUI();
                
                document.getElementById('vocab-input').value = '';
                
                // W√§hle neue Vokabel
                selectRandomVocab();
                
                // Start new timer for next vocab
                startVocabTimer();
            } else {
                // Wrong - Monti f√§llt 50m!
                clearInterval(vocabTimer); // Stop timer
                
                const newAltitude = Math.max(gameState.altitude - 50, 0); // Min 0m
                gameState.altitude = newAltitude;
                targetAltitude = newAltitude;
                
                // Trigger falling animation
                triggerFall();
                
                // Show -50 Meter popup
                showPointsPopup('-50 Meter', false);
                
                showFeedback('Falsch! ‚úó', false);
                updateUI();
                
                document.getElementById('vocab-input').value = '';
                
                // Check if crashed
                if (gameState.altitude <= 0) {
                    setTimeout(() => {
                        endGame();
                    }, 1000); // Warte kurz bevor Game Over
                } else {
                    // W√§hle neue Vokabel
                    selectRandomVocab();
                    
                    // Start new timer for next vocab
                    startVocabTimer();
                }
            }
        }

        function showPointsPopup(text, isPositive) {
            const popup = document.createElement('div');
            popup.textContent = text;
            popup.style.position = 'absolute';
            
            // Zuf√§llige Position um Monti herum (45-55% horizontal, 35-45% vertikal)
            const randomX = 45 + Math.random() * 10; // 45-55%
            const randomY = 35 + Math.random() * 10; // 35-45%
            
            popup.style.left = randomX + '%';
            popup.style.top = randomY + '%';
            popup.style.transform = 'translate(-50%, -50%)';
            popup.style.fontSize = '48px';
            popup.style.fontWeight = 'bold';
            popup.style.color = isPositive ? '#00FF00' : '#FF0000';
            popup.style.textShadow = '3px 3px 0px rgba(0, 0, 0, 0.5)';
            popup.style.pointerEvents = 'none';
            popup.style.zIndex = '1000';
            popup.style.animation = 'popupBurst 0.8s ease-out forwards';
            
            document.getElementById('ui-overlay').appendChild(popup);
            
            // Remove after animation
            setTimeout(() => {
                popup.remove();
            }, 800);
        }

        // CSS f√ºr popup animation wird im style-tag hinzugef√ºgt

        function showFeedback(text, isCorrect) {
            const feedback = document.getElementById('feedback');
            feedback.textContent = text;
            feedback.className = isCorrect ? 'correct' : 'wrong';
            feedback.style.display = 'block';
            
            setTimeout(() => {
                feedback.style.display = 'none';
            }, 1000);
        }

        function endGame() {
            clearInterval(gameInterval);
            clearInterval(vocabTimer);
            gameState.isPlaying = false;
            
            document.getElementById('final-score-value').textContent = gameState.score;
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        // Event Listeners
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const introScreen = document.getElementById('intro-screen');
                if (introScreen.style.display !== 'none') {
                    // Start countdown
                    introScreen.style.display = 'none';
                    startCountdown();
                } else if (gameState.isPlaying) {
                    // Check answer
                    const input = document.getElementById('vocab-input');
                    if (input.value.trim()) {
                        checkAnswer(input.value);
                    }
                }
            }
        });

        function startCountdown() {
            const countdownScreen = document.getElementById('countdown-screen');
            const countdownNumber = document.getElementById('countdown-number');
            
            countdownScreen.style.display = 'flex';
            
            let count = 3;
            countdownNumber.textContent = count;
            
            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownNumber.textContent = count;
                    // Trigger animation restart
                    countdownNumber.style.animation = 'none';
                    setTimeout(() => {
                        countdownNumber.style.animation = 'countdownPop 0.5s ease-out';
                    }, 10);
                } else {
                    countdownNumber.textContent = 'GO!';
                    countdownNumber.style.animation = 'none';
                    setTimeout(() => {
                        countdownNumber.style.animation = 'countdownPop 0.5s ease-out';
                    }, 10);
                    
                    setTimeout(() => {
                        countdownScreen.style.display = 'none';
                        startGame();
                    }, 800);
                    
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }

        // Initialize
        async function init() {
            const success = await loadUserAndVocabs();
            if (success) {
                selectRandomVocab(); // Setze erste Vokabel
                initThreeJS();
                animate();
            }
        }
        
        init();
    </script>
</body>
</html>
