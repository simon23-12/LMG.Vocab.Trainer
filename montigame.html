
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monti Game - LMG Vokabeltrainer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%);
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #intro-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0066CC 0%, #00AAFF 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: all;
            overflow: hidden;
        }
        
        #intro-screen::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: url('https://github.com/simon23-12/LMG.Vocab.Trainer/blob/main/images/montigame.jpg?raw=true');
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0;
            animation: fadeInImage 1s ease-in-out 0.5s forwards;
        }

        @keyframes fadeInImage {
            to { opacity: 1; }
        }

        #intro-screen .content-wrapper {
            position: relative;
            z-index: 10;
            text-align: center;
            max-width: 800px;
            padding: 40px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 25px;
            border: 4px solid #FFB700;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideInUp 0.8s ease-out 1.2s both;
        }

        @keyframes slideInUp {
            from {
                transform: translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        #intro-screen .game-title {
            font-size: 56px;
            font-weight: bold;
            color: #0066CC;
            margin-bottom: 10px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-shadow: 2px 2px 0px #FFB700;
            animation: titlePulse 2s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        #intro-screen .game-subtitle {
            font-size: 22px;
            color: #666;
            margin-bottom: 30px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #intro-screen .rules {
            background: #f0f7ff;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            border: 2px solid #0066CC;
            text-align: left;
        }

        #intro-screen .rules h2 {
            color: #0066CC;
            margin-bottom: 15px;
            font-size: 24px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #intro-screen .rules ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #intro-screen .rules li {
            font-size: 17px;
            line-height: 1.8;
            margin-bottom: 10px;
            padding-left: 30px;
            position: relative;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #333;
        }

        #intro-screen .rules li::before {
            content: '‚úì';
            position: absolute;
            left: 0;
            color: #FFB700;
            font-weight: bold;
            font-size: 20px;
        }

        #intro-screen .start-hint {
            font-size: 28px;
            animation: pulse 1.5s infinite;
            color: #0066CC;
            font-weight: bold;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #FFB700;
            padding: 15px 40px;
            border-radius: 50px;
            display: inline-block;
            border: 3px solid #0066CC;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #intro-screen .start-hint:hover {
            transform: scale(1.1);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }

        #countdown-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 100, 200, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            pointer-events: all;
        }

        #countdown-screen .countdown-number {
            font-size: 150px;
            font-weight: bold;
            color: #FFB700;
            text-shadow: 5px 5px 0px #0066CC;
            animation: countdownPop 0.5s ease-out;
        }

        @keyframes countdownPop {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        #game-ui {
            display: none;
        }

        #altitude-meter {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 100, 200, 0.8);
            color: white;
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #FFB700;
            min-width: 150px;
            text-align: center;
        }

        #altitude-meter .label {
            font-size: 14px;
            margin-bottom: 5px;
        }

        #altitude-meter .value {
            font-size: 36px;
            font-weight: bold;
            color: #FFB700;
        }

        #altitude-meter .unit {
            font-size: 18px;
        }

        #streak-counter {
            position: absolute;
            top: 150px;
            right: 20px;
            background: rgba(255, 183, 0, 0.9);
            color: white;
            padding: 12px 18px;
            border-radius: 15px;
            border: 3px solid #0066CC;
            min-width: 150px;
            text-align: center;
            transition: all 0.3s ease;
        }

        #streak-counter.boost-active {
            background: rgba(0, 255, 0, 0.9);
            border-color: #FFB700;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.6);
            animation: boostPulse 0.5s infinite;
        }

        @keyframes boostPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        #streak-counter .label {
            font-size: 12px;
            margin-bottom: 3px;
        }

        #streak-counter .value {
            font-size: 28px;
            font-weight: bold;
            color: #0066CC;
        }

        #streak-counter.boost-active .value {
            color: white;
        }

        #boost-indicator {
            display: none;
            font-size: 14px;
            font-weight: bold;
            margin-top: 5px;
            color: white;
        }

        #streak-counter.boost-active #boost-indicator {
            display: block;
        }

        #highscore-display {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 20px;
            border-radius: 15px;
            border: 3px solid #FFB700;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        #highscore-display .label {
            font-size: 14px;
            color: #0066CC;
            font-weight: bold;
            margin-bottom: 5px;
        }

        #highscore-display .value {
            font-size: 36px;
            font-weight: bold;
            color: #FFB700;
            text-shadow: 2px 2px 0px #0066CC;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #score-display {
            position: absolute;
            top: 120px;
            left: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 20px;
            border-radius: 15px;
            border: 3px solid #0066CC;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        #score-display .label {
            font-size: 14px;
            color: #0066CC;
            font-weight: bold;
            margin-bottom: 5px;
        }

        #score-display .value {
            font-size: 48px;
            font-weight: bold;
            color: #0066CC;
            text-shadow: 2px 2px 0px #FFB700;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #vocab-input-container {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 30px;
            border-radius: 15px;
            border: 3px solid #0066CC;
            min-width: 400px;
            pointer-events: all;
        }

        #vocab-question {
            font-size: 24px;
            color: #0066CC;
            margin-bottom: 10px;
            text-align: center;
            font-weight: bold;
        }

        #vocab-input {
            width: 100%;
            padding: 15px;
            font-size: 20px;
            border: 2px solid #0066CC;
            border-radius: 10px;
            text-align: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin-bottom: 10px;
        }

        #vocab-input:focus {
            outline: none;
            border-color: #FFB700;
            box-shadow: 0 0 10px rgba(255, 183, 0, 0.5);
        }

        #timer-bar-container {
            width: 100%;
            height: 8px;
            background: #ddd;
            border-radius: 4px;
            overflow: hidden;
        }

        #timer-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #FF0000, #FFB700, #00FF00);
            transition: width 0.1s linear;
            transform-origin: left;
        }

        #feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            display: none;
            text-shadow: 3px 3px 0px rgba(0, 0, 0, 0.3);
            animation: feedbackPop 0.5s ease-out;
        }

        #feedback.correct {
            color: #00FF00;
        }

        #feedback.wrong {
            color: #FF0000;
        }

        @keyframes feedbackPop {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('https://github.com/simon23-12/LMG.Vocab.Trainer/blob/main/images/montilanded.jpg?raw=true');
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            background-color: #87CEEB;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: all;
        }

        #game-over-screen .content-overlay {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px 60px;
            border-radius: 25px;
            border: 4px solid #FFB700;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            text-align: center;
        }

        #game-over-screen .final-score {
            font-size: 36px;
            margin-bottom: 30px;
            color: #0066CC;
            font-weight: bold;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #game-over-screen .final-score span {
            color: #FFB700;
            font-size: 48px;
            text-shadow: 2px 2px 0px #0066CC;
        }

        #game-over-screen button {
            padding: 15px 40px;
            font-size: 24px;
            background: #FFB700;
            color: #0066CC;
            border: 3px solid #0066CC;
            border-radius: 15px;
            cursor: pointer;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: bold;
            transition: all 0.3s;
        }

        #game-over-screen button:hover {
            background: #FFC700;
            transform: scale(1.05);
        }
        @keyframes popupBurst {
            0% { 
                transform: translate(-50%, -50%) scale(0); 
                opacity: 0; 
            }
            30% { 
                transform: translate(-50%, -50%) scale(1.3); 
                opacity: 1; 
            }
            60% {
                transform: translate(-50%, -60%) scale(1);
                opacity: 1;
            }
            100% { 
                transform: translate(-50%, -80%) scale(0.5); 
                opacity: 0; 
            }
        }

        /* Mobile Optimierungen */
        @media only screen and (max-width: 768px) {
            /* Intro Screen */
            #intro-screen .content-wrapper {
                max-width: 90%;
                padding: 20px;
                margin: 10px;
            }

            #intro-screen .game-title {
                font-size: 36px;
            }

            #intro-screen .game-subtitle {
                font-size: 16px;
                margin-bottom: 20px;
            }

            #intro-screen .rules {
                padding: 15px;
                margin-bottom: 20px;
            }

            #intro-screen .rules h2 {
                font-size: 20px;
                margin-bottom: 10px;
            }

            #intro-screen .rules li {
                font-size: 14px;
                line-height: 1.6;
                padding-left: 25px;
            }

            #intro-screen .start-hint {
                font-size: 22px;
                padding: 12px 30px;
            }

            /* Game UI */
            #highscore-display {
                top: 10px;
                left: 10px;
                padding: 10px 15px;
            }

            #highscore-display .label {
                font-size: 11px;
            }

            #highscore-display .value {
                font-size: 28px;
            }

            #score-display {
                top: 95px;
                left: 10px;
                padding: 10px 15px;
            }

            #score-display .label {
                font-size: 11px;
            }

            #score-display .value {
                font-size: 36px;
            }

            #altitude-meter {
                top: 10px;
                right: 10px;
                padding: 12px 15px;
                min-width: 100px;
            }

            #altitude-meter .label {
                font-size: 11px;
            }

            #altitude-meter .value {
                font-size: 28px;
            }

            #altitude-meter .unit {
                font-size: 14px;
            }

            #streak-counter {
                top: 120px;
                right: 10px;
                padding: 8px 12px;
                min-width: 140px;
            }

            #streak-counter .label {
                font-size: 10px;
            }

            #streak-counter .value {
                font-size: 22px;
            }

            #boost-indicator {
                font-size: 11px;
            }

            #vocab-input-container {
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                min-width: 90%;
                padding: 15px 20px;
            }

            #vocab-question {
                font-size: 20px;
            }

            #vocab-input {
                padding: 12px;
                font-size: 18px;
            }

            /* Countdown */
            #countdown-screen .countdown-number {
                font-size: 100px;
            }

            /* Game Over */
            #game-over-screen h1 {
                font-size: 40px;
            }

            #game-over-screen .final-score {
                font-size: 28px;
            }

            #game-over-screen button {
                font-size: 18px;
                padding: 12px 30px;
            }

            /* Feedback */
            #feedback {
                font-size: 36px;
            }
        }

        /* Extra kleine Screens (unter 480px) */
        @media only screen and (max-width: 480px) {
            #intro-screen .game-title {
                font-size: 28px;
            }

            #intro-screen .rules li {
                font-size: 13px;
            }

            #vocab-input-container {
                min-width: 95%;
                padding: 12px 15px;
            }

            #vocab-question {
                font-size: 18px;
            }

            #vocab-input {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-overlay">
        <!-- Intro Screen -->
        <div id="intro-screen">
            <div class="content-wrapper">
                <div class="game-title">MONTI GAME</div>
                <div class="game-subtitle">Das gro√üe Vokabel-Abenteuer</div>
                
                <div class="rules">
                    <h2>üéÆ Spielregeln:</h2>
                    <ul>
                        <li>Halte Monti in der Luft durch richtiges Beantworten von Vokabeln!</li>
                        <li>Es kommen zuf√§llig Vokabeln aller Seiten dran, die du bisher ge√ºbt hast</li>
                        <li>Bei 0 Meter landet Monti und das Spiel endet</li>
                        <li>Schaffst du heute einen neuen Highscore?</li>
                    </ul>
                </div>
                
                <div class="start-hint" onclick="document.getElementById('intro-screen').style.display='none'; startCountdown();">
                    ‚ñ∂ Start!
                </div>
                
                <button onclick="window.location.href='display.html'" style="margin-top: 20px; background: #0066CC; color: white; border: 2px solid #FFB700; padding: 12px 30px; border-radius: 10px; font-size: 18px; cursor: pointer; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; transition: all 0.3s;">
                    ‚Üê Zur√ºck zum Men√º
                </button>
            </div>
        </div>

        <!-- Countdown Screen -->
        <div id="countdown-screen">
            <div class="countdown-number" id="countdown-number">3</div>
        </div>

        <!-- Game UI -->
        <div id="game-ui">
            <div id="highscore-display">
                <div class="label">HIGHSCORE</div>
                <div class="value" id="highscore-value">0</div>
            </div>

            <div id="score-display">
                <div class="label">SCORE</div>
                <div class="value" id="score-value">0</div>
            </div>

            <div id="altitude-meter">
                <div class="label">H√ñHE</div>
                <div class="value" id="altitude-value">100</div>
                <div class="unit">m</div>
            </div>

            <div id="streak-counter">
                <div class="label">STREAK</div>
                <div class="value" id="streak-value">0</div>
                <div id="boost-indicator">üöÄ TURBO! üöÄ</div>
            </div>

            <div id="vocab-input-container">
                <div id="vocab-question">test</div>
                <input type="text" id="vocab-input" autocomplete="off" placeholder="√úbersetzung eingeben...">
                <div id="timer-bar-container">
                    <div id="timer-bar"></div>
                </div>
            </div>

            <div id="feedback"></div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen">
            <div class="content-overlay">
                <div class="final-score">Dein Score: <span id="final-score-value">0</span></div>
                <button onclick="location.reload()">Nochmal spielen</button>
            </div>
        </div>
    </div>

    <!-- Firebase Scripts -->
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        const gameState = {
            altitude: 100,
            score: 0,
            isPlaying: false,
            isPaused: false
        };

        // Firebase Config (gleich wie in display.html)
        const firebaseConfig = {
            apiKey: "AIzaSyBRPlWh1slILKg8DWQDOEWXSFsnUK3j1vw",
            authDomain: "testdatabase-4daf4.firebaseapp.com",
            databaseURL: "https://testdatabase-4daf4-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "testdatabase-4daf4",
            storageBucket: "testdatabase-4daf4.firebasestorage.app",
            messagingSenderId: "743231387214",
            appId: "1:743231387214:web:166169b25f72616280351f"
        };

        // User & Vocabulary data
        let currentUser = null;
        let userPerformance = {};
        let availableVocabs = []; // Vokabeln von ge√ºbten Seiten
        let currentVocab = null;
        let usedVocabs = []; // Bereits gespielte Vokabeln in dieser Session
        let highscore = 0; // Bester Score
        
        // Firebase initialisieren f√ºr Highscore-Speicherung
        let db = null;
        
        function initFirebase() {
            try {
                if (typeof firebase === 'undefined') {
                    console.warn('Firebase nicht geladen, Highscore-Speicherung nicht verf√ºgbar');
                    return;
                }
                
                firebase.initializeApp(firebaseConfig);
                db = firebase.database();
                console.log('‚úì Firebase initialisiert f√ºr Highscore');
            } catch (error) {
                console.error('Firebase Init Fehler:', error);
            }
        }

        // Lade User-Daten und Vokabeln
        async function loadUserAndVocabs() {
            try {
                // Lade User aus localStorage
                const savedUser = localStorage.getItem('lmg_currentUser');
                const savedPerformance = localStorage.getItem('lmg_userPerformance');
                
                if (!savedUser) {
                    alert('Bitte logge dich zuerst ein!');
                    window.location.href = 'index.html';
                    return false;
                }
                
                currentUser = JSON.parse(savedUser);
                userPerformance = savedPerformance ? JSON.parse(savedPerformance) : {};
                
                console.log('‚úì User geladen:', currentUser.name);
                console.log('‚úì Performance:', userPerformance);
                
                // Lade Highscore aus Firebase
                if (db && currentUser.userKey) {
                    try {
                        const snapshot = await db.ref('users/' + currentUser.userKey + '/montiGameHighscore').once('value');
                        highscore = snapshot.val() || 0;
                        console.log('‚úì Highscore geladen:', highscore);
                        document.getElementById('highscore-value').textContent = highscore;
                    } catch (error) {
                        console.error('Fehler beim Laden des Highscores:', error);
                        highscore = 0;
                    }
                }
                
                // Finde alle ge√ºbten Seiten
                const practicedPages = Object.keys(userPerformance).map(key => {
                    const match = key.match(/^page_(\d+)$/);
                    return match ? parseInt(match[1]) : null;
                }).filter(p => p !== null);
                
                console.log('‚úì Ge√ºbte Seiten:', practicedPages);
                
                if (practicedPages.length === 0) {
                    alert('Du hast noch keine Seiten ge√ºbt! √úbe zuerst ein paar Seiten, bevor du das Monti Game spielst.');
                    window.location.href = 'display.html';
                    return false;
                }
                
                // Lade Vokabeln EINMAL von GitHub
                try {
                    // Nutze jahrgang (nicht class!) - "5" f√ºr Klasse 5a/5b
                    const jahrgang = currentUser.jahrgang || '5';
                    const vocabFile = `voc${jahrgang}_4.json`;
                    
                    console.log('üîç jahrgang:', jahrgang);
                    console.log('üîç vocabFile:', vocabFile);
                    
                    // Korrekte GitHub URL (wie in display.html)
                    const url = `https://raw.githubusercontent.com/simon23-12/LMG.Vocab.Trainer/main/vocab/english/${vocabFile}`;
                    
                    console.log('üì• Lade Vokabeln von:', url);
                    
                    const response = await fetch(url);
                    const text = await response.text();
                    const allVocabs = JSON.parse(text);
                    
                    console.log('‚úì JSON geladen, insgesamt', allVocabs.length, 'Vokabeln');
                    
                    // Filtere nur Vokabeln von ge√ºbten Seiten
                    availableVocabs = allVocabs.filter(v => 
                        practicedPages.includes(parseInt(v.Page))
                    );
                    
                    console.log('‚úì Gefilterte Vokabeln von ge√ºbten Seiten:', availableVocabs.length);
                    console.log('‚úì Beispiel-Vokabel:', availableVocabs[0]);
                    
                } catch (error) {
                    console.error('Fehler beim Laden der Vokabeln:', error);
                    alert('Fehler beim Laden der Vokabeln!');
                    window.location.href = 'display.html';
                    return false;
                }
                
                if (availableVocabs.length === 0) {
                    alert('Keine Vokabeln gefunden!');
                    window.location.href = 'display.html';
                    return false;
                }
                
                return true;
            } catch (error) {
                console.error('Fehler beim Laden:', error);
                alert('Fehler beim Laden der Daten!');
                return false;
            }
        }

        // W√§hle zuf√§llige neue Vokabel
        function selectRandomVocab() {
            // Filtere bereits verwendete Vokabeln raus
            const unused = availableVocabs.filter(v => 
                !usedVocabs.some(used => used.English === v.English)
            );
            
            // Wenn alle verwendet wurden, reset
            if (unused.length === 0) {
                console.log('Alle Vokabeln gespielt, reset!');
                usedVocabs = [];
                return selectRandomVocab();
            }
            
            // W√§hle zuf√§llige Vokabel
            const randomVocab = unused[Math.floor(Math.random() * unused.length)];
            usedVocabs.push(randomVocab);
            
            currentVocab = {
                question: randomVocab.German, // Frage ist auf Deutsch
                answers: [randomVocab.English, ...(randomVocab.synonyms || [])] // Antworten sind Englisch + Synonyme
            };
            
            console.log('Neue Vokabel:', currentVocab);
            
            // Update UI
            document.getElementById('vocab-question').textContent = currentVocab.question;
        }

        // Three.js Setup
        let scene, camera, renderer, monti;
        let altitudeDelta = 0; // F√ºr smooth altitude changes

        function initThreeJS() {
            const canvas = document.getElementById('gameCanvas');
            scene = new THREE.Scene();
            
            // Atmosph√§rischer Nebel f√ºr Tiefe
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.002);
            
            // Camera - from behind and slightly above
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5.5, 10); // H√∂her f√ºr bessere Sicht auf Monti
            camera.lookAt(0, 3.5, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB, 1);
            renderer.outputEncoding = THREE.sRGBEncoding;

            // Besseres Lighting: Hemisphere + Directional (wie Sonne)
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
            scene.add(hemiLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(50, 100, 50);
            scene.add(sunLight);

            // Create Monti the Bird
            createMonti();
            
            // Mache Monti zu einem Kind der Kamera, damit er immer im Viewport bleibt
            camera.add(monti);
            monti.position.set(0, 0.2, -8); // Noch h√∂her: 0.2
            
            // F√ºge Kamera zur Scene hinzu (wichtig f√ºr Children)
            scene.add(camera);

            // Create Clouds
            createClouds();

            // Create Landscape
            createLandscape();

            // Window resize handler
            window.addEventListener('resize', onWindowResize);
        }

        function createMonti() {
            monti = new THREE.Group();

            // Body (Yellow center - LMG Gelb) - 30% kleiner
            const bodyGeometry = new THREE.SphereGeometry(0.28, 32, 32); // 0.28 statt 0.4 (30% kleiner)
            const bodyMaterial = new THREE.MeshToonMaterial({ color: 0xFFB700 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = -0.5;
            monti.add(body);
            monti.body = body; // Speichere Referenz f√ºr Animation

            // Create detailed wings with LMG color gradient
            const leftWing = createDetailedWing();
            leftWing.position.set(-0.5, 0, -0.15);
            leftWing.rotation.y = Math.PI * 0.3;
            leftWing.rotation.z = -Math.PI * 0.3; // Ausgebreitet
            leftWing.rotation.x = -0.1;
            monti.add(leftWing);
            monti.leftWing = leftWing;

            const rightWing = createDetailedWing();
            rightWing.scale.x = -1; // Mirror
            rightWing.position.set(0.5, 0, -0.15);
            rightWing.rotation.y = -Math.PI * 0.3;
            rightWing.rotation.z = Math.PI * 0.3; // Ausgebreitet
            rightWing.rotation.x = -0.1;
            monti.add(rightWing);
            monti.rightWing = rightWing;

            // KEINE Schwanzfedern mehr!
            
            // Boost-Glow-Sphere (unsichtbar beim Start)
            const glowGeometry = new THREE.SphereGeometry(1.2, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00FF00,
                transparent: true,
                opacity: 0,
                wireframe: false
            });
            const glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
            glowSphere.position.y = -0.5;
            monti.add(glowSphere);
            monti.boostGlow = glowSphere; // Referenz speichern
            
            // Kondensstreifen-Partikel
            monti.trailParticles = [];

            monti.rotation.x = -0.1; // Slight forward tilt
            // Position wird √ºber camera.add() gesetzt
        }

        function createDetailedWing() {
            const wing = new THREE.Group();
            
            // Wing structure: Nur √§u√üere Federn - keine inneren gelben/hellblauen mehr
            const featherLayers = [
                // Outer feathers (tips) - Navy blue
                { color: 0x000080, length: 3.0, width: 0.18, count: 5, startAngle: 0, spread: 0.6 },
                // Mid-outer - LMG Blue
                { color: 0x0066CC, length: 2.8, width: 0.2, count: 5, startAngle: 0.1, spread: 0.5 },
                // Mid - Steel Blue
                { color: 0x4682B4, length: 2.6, width: 0.22, count: 5, startAngle: 0.2, spread: 0.45 },
                // Mid-inner - Cyan
                { color: 0x00CED1, length: 2.4, width: 0.24, count: 5, startAngle: 0.3, spread: 0.4 }
                // ENTFERNT: Aquamarine und Gold Layer die oben sichtbar waren
            ];

            featherLayers.forEach((layer, layerIndex) => {
                for (let i = 0; i < layer.count; i++) {
                    const featherGeometry = new THREE.BoxGeometry(layer.width, layer.length, 0.05);
                    const featherMaterial = new THREE.MeshToonMaterial({ color: layer.color });
                    const feather = new THREE.Mesh(featherGeometry, featherMaterial);
                    
                    const angle = layer.startAngle + (i / layer.count) * layer.spread;
                    const radius = 1.2 + layerIndex * 0.15;
                    
                    feather.position.x = Math.sin(angle) * radius;
                    feather.position.y = -Math.cos(angle) * radius * 0.5;
                    feather.position.z = layerIndex * 0.02;
                    feather.rotation.z = angle - Math.PI / 2;
                    
                    wing.add(feather);
                }
            });

            return wing;
        }

        function createClouds() {
            // Clouds above (at 200m+ altitude)
            const cloudGeometry = new THREE.SphereGeometry(1, 16, 16);
            const cloudMaterial = new THREE.MeshToonMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.9 
            });

            window.clouds = []; // Array f√ºr Wolken-Referenzen

            for (let i = 0; i < 15; i++) {
                const cloud = new THREE.Group();
                
                // Multiple spheres for cloud shape
                for (let j = 0; j < 6; j++) {
                    const cloudPart = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    cloudPart.scale.set(
                        Math.random() * 0.8 + 0.6,
                        Math.random() * 0.4 + 0.3,
                        Math.random() * 0.8 + 0.6
                    );
                    cloudPart.position.set(
                        Math.random() * 2.5 - 1.25,
                        Math.random() * 0.8,
                        Math.random() * 2.5 - 1.25
                    );
                    cloud.add(cloudPart);
                }

                cloud.position.set(
                    Math.random() * 60 - 30,
                    20 + Math.random() * 5,  // High up for 200m altitude
                    Math.random() * 60 - 80
                );
                
                scene.add(cloud);
                window.clouds.push(cloud); // Speichere Referenz
            }
        }

        // Create scrolling landscape below
        let landscapeSegments = [];
        
        function createLandscape() {
            // Erstelle 3 Landschafts-Segmente f√ºr nahtloses Loop - NOCH GR√ñSSER
            for (let seg = 0; seg < 3; seg++) {
                const segment = new THREE.Group();
                const zOffset = seg * 800 - 800; // Noch l√§nger: 800 statt 500
                
                // Ground plane (grass) - NOCH GR√ñSSER
                const groundGeometry = new THREE.PlaneGeometry(600, 800); // 600x800 statt 400x500
                const groundMaterial = new THREE.MeshToonMaterial({ 
                    color: 0x7CFC00,  // Lawn green
                    side: THREE.DoubleSide 
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -15;
                ground.position.z = 0; // Relativ zum Segment
                segment.add(ground);
                
                // Add texture variation with darker green patches - NOCH MEHR Patches
                for (let i = 0; i < 100; i++) { // 100 statt 60
                    const patchGeometry = new THREE.CircleGeometry(Math.random() * 4 + 2, 16);
                    const patchMaterial = new THREE.MeshToonMaterial({ 
                        color: 0x228B22,  // Forest green
                        side: THREE.DoubleSide 
                    });
                    const patch = new THREE.Mesh(patchGeometry, patchMaterial);
                    patch.rotation.x = -Math.PI / 2;
                    patch.position.set(
                        Math.random() * 580 - 290, // Breiter verteilt
                        -14.9,
                        Math.random() * 780 - 390  // L√§nger verteilt
                    );
                    segment.add(patch);
                }
                
                // Lakes/ponds - NOCH MEHR Seen
                for (let i = 0; i < 25; i++) { // 25 statt 15
                    const lakeGeometry = new THREE.CircleGeometry(Math.random() * 10 + 5, 16);
                    const lakeMaterial = new THREE.MeshToonMaterial({ 
                        color: 0x1E90FF,  // Dodger blue
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.8
                    });
                    const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
                    lake.rotation.x = -Math.PI / 2;
                    lake.position.set(
                        Math.random() * 560 - 280, // Breiter
                        -14.8,
                        Math.random() * 760 - 380  // L√§nger
                    );
                    segment.add(lake);
                }
                
                // Trees - NOCH VIEL MEHR B√§ume
                for (let i = 0; i < 150; i++) { // 150 statt 100
                    const tree = createTree();
                    tree.position.set(
                        Math.random() * 580 - 290, // Breiter
                        -15,
                        Math.random() * 780 - 390  // L√§nger
                    );
                    segment.add(tree);
                }
                
                // Berge links und rechts F√úR JEDES SEGMENT - NOCH MEHR und NOCH WEITER AU√üEN
                // Linke Berge
                for (let i = 0; i < 8; i++) { // 8 statt 6
                    const mountain = createMountain();
                    mountain.position.set(
                        -220 - (Math.random() * 80), // Noch weiter links
                        -12,
                        Math.random() * 780 - 390
                    );
                    segment.add(mountain);
                }
                
                // Rechte Berge
                for (let i = 0; i < 8; i++) { // 8 statt 6
                    const mountain = createMountain();
                    mountain.position.set(
                        220 + (Math.random() * 80), // Noch weiter rechts
                        -12,
                        Math.random() * 780 - 390
                    );
                    segment.add(mountain);
                }
                
                segment.position.z = zOffset;
                landscapeSegments.push(segment);
                scene.add(segment);
            }
        }
        
        function createMountain() {
            const mountainPart = new THREE.Group();
            
            const mountainHeight = Math.random() * 20 + 25;
            const mountainWidth = Math.random() * 10 + 12;
            
            // Hauptkegel mit mehreren Segmenten f√ºr Textur
            const mainPeakGeometry = new THREE.ConeGeometry(
                mountainWidth,
                mountainHeight,
                6,
                8
            );
            
            const grayValue = Math.random() * 0.2 + 0.35; // 0.35-0.55
            const mountainColor = new THREE.Color(grayValue, grayValue, grayValue);
            const mainPeakMaterial = new THREE.MeshToonMaterial({ 
                color: mountainColor,
                flatShading: true
            });
            const mainPeak = new THREE.Mesh(mainPeakGeometry, mainPeakMaterial);
            mainPeak.rotation.z = (Math.random() - 0.5) * 0.2;
            mountainPart.add(mainPeak);
            
            // 1-2 Nebengipfel f√ºr Unregelm√§√üigkeit
            const sideCount = Math.random() > 0.5 ? 2 : 1;
            for (let j = 0; j < sideCount; j++) {
                const sidePeakGeometry = new THREE.ConeGeometry(
                    mountainWidth * 0.5,
                    mountainHeight * 0.65,
                    5,
                    6
                );
                const sidePeak = new THREE.Mesh(sidePeakGeometry, mainPeakMaterial);
                sidePeak.position.x = (j === 0 ? -1 : 1) * mountainWidth * 0.6;
                sidePeak.position.y = -mountainHeight * 0.25;
                sidePeak.rotation.z = (Math.random() - 0.5) * 0.3;
                mountainPart.add(sidePeak);
            }
            
            // Schneekappe - KLEINER als der Berg
            const snowCapGeometry = new THREE.ConeGeometry(
                mountainWidth * 0.25,  // Viel kleiner!
                mountainHeight * 0.2,  // Nur 20% der Bergh√∂he
                6,
                3
            );
            const snowCapMaterial = new THREE.MeshToonMaterial({ 
                color: 0xFFFAFA,
                flatShading: true
            });
            const snowCap = new THREE.Mesh(snowCapGeometry, snowCapMaterial);
            snowCap.position.y = mountainHeight * 0.4;  // Oben auf dem Berg
            snowCap.rotation.z = mainPeak.rotation.z;
            mountainPart.add(snowCap);
            
            return mountainPart;
        }
        
        function createTree() {
            const tree = new THREE.Group();
            
            // Variabler Stamm (H√∂he und Dicke)
            const trunkHeight = 1.5 + Math.random() * 1.0; // 1.5 - 2.5
            const trunkRadius = 0.25 + Math.random() * 0.15; // 0.25 - 0.4
            const trunkGeometry = new THREE.CylinderGeometry(trunkRadius, trunkRadius * 1.2, trunkHeight, 6);
            const trunkMaterial = new THREE.MeshToonMaterial({ color: 0x5D4037 }); // Dunkleres Braun
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2;
            tree.add(trunk);
            
            // Variierende Baumkrone (Kugel f√ºr Laubb√§ume)
            const foliageSize = 0.7 + Math.random() * 0.4; // 0.7 - 1.1
            const foliageGeometry = new THREE.SphereGeometry(foliageSize, 6, 6);
            // Verschiedene Gr√ºnt√∂ne
            const greenShades = [0x2E7D32, 0x43A047, 0x66BB6A, 0x228B22];
            const foliageColor = greenShades[Math.floor(Math.random() * greenShades.length)];
            const foliageMaterial = new THREE.MeshToonMaterial({ color: foliageColor });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = trunkHeight + foliageSize * 0.4;
            foliage.scale.set(1, 1.2, 1); // Leicht oval
            tree.add(foliage);
            
            return tree;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation
        let wingFlapTime = 0;
        let bobTime = 0;
        const landscapeScrollSpeed = 0.3;
        let isFlapping = false;
        let flapDuration = 0;
        let isFalling = false;
        let fallDuration = 0;
        let fallTime = 0;
        
        // Streak & Boost System
        let streakCount = 0;
        let boostActive = false;
        let boostDuration = 0;
        const STREAK_FOR_BOOST = 5; // 5 richtige Antworten
        const BOOST_TIME = 2.0; // 2 Sekunden Beschleunigung

        function animate() {
            requestAnimationFrame(animate);

            if (monti) {
                if (isFalling) {
                    // Fall-Animation bei falscher Antwort
                    fallTime += 0.016;
                    
                    // Fl√ºgel klappen zusammen
                    const collapseAngle = Math.min(fallTime * 2, 1) * (Math.PI * 0.4);
                    monti.leftWing.rotation.z = -Math.PI * 0.25 - collapseAngle;
                    monti.rightWing.rotation.z = Math.PI * 0.25 + collapseAngle;
                    
                    // K√∂rper taumelt
                    monti.rotation.x = -0.1 + Math.sin(fallTime * 10) * 0.2;
                    monti.rotation.z = Math.sin(fallTime * 8) * 0.15;
                    
                    // K√∂rper vibriert
                    const shake = Math.sin(fallTime * 20) * 0.05;
                    monti.body.position.y = -0.5 + shake;
                    
                    fallDuration -= 0.016;
                    if (fallDuration <= 0) {
                        isFalling = false;
                        // Reset zu Gleitflug-Position
                        monti.leftWing.rotation.z = -Math.PI * 0.25;
                        monti.rightWing.rotation.z = Math.PI * 0.25;
                        monti.body.position.y = -0.5;
                        monti.rotation.x = -0.1;
                        monti.rotation.z = 0;
                    }
                } else if (isFlapping) {
                    // Aktiver Fl√ºgelschlag bei richtigen Antworten
                    wingFlapTime += 0.25;
                    const flapAngle = Math.sin(wingFlapTime) * 0.4;
                    monti.leftWing.rotation.z = -Math.PI * 0.25 + flapAngle;
                    monti.rightWing.rotation.z = Math.PI * 0.25 - flapAngle;
                    
                    // K√∂rper-Animation beim Flattern
                    const bodyBounce = Math.abs(Math.sin(wingFlapTime)) * 0.08;
                    monti.body.position.y = -0.5 + bodyBounce;
                    
                    // Leichte Rotationsbewegung des ganzen Vogels
                    monti.rotation.x = -0.1 + Math.sin(wingFlapTime) * 0.05;
                    
                    flapDuration -= 0.016; // ca. 60fps
                    if (flapDuration <= 0) {
                        isFlapping = false;
                        // Reset zu Gleitflug-Position
                        monti.leftWing.rotation.z = -Math.PI * 0.25;
                        monti.rightWing.rotation.z = Math.PI * 0.25;
                        monti.body.position.y = -0.5;
                        monti.rotation.x = -0.1;
                    }
                } else {
                    // Sanftes Gleiten - minimal wing adjustment
                    wingFlapTime += 0.02;
                    const glideAngle = Math.sin(wingFlapTime) * 0.05;
                    monti.leftWing.rotation.z = -Math.PI * 0.25 + glideAngle;
                    monti.rightWing.rotation.z = Math.PI * 0.25 - glideAngle;
                    
                    // Subtile K√∂rperbewegung auch beim Gleiten
                    const subtleBodyMove = Math.sin(wingFlapTime * 0.5) * 0.01;
                    monti.body.position.y = -0.5 + subtleBodyMove;
                    
                    // Nat√ºrliches Banking (leichtes Kippen wie ein Vogel)
                    const time = Date.now() * 0.001;
                    monti.rotation.z = Math.sin(time * 0.5) * 0.03;
                }

                // Sehr subtiles bobbing - relativ zur Kamera-Position (nur wenn nicht fallend)
                if (!isFalling) {
                    bobTime += 0.02;
                    const bobbingOffset = Math.sin(bobTime) * 0.03;
                    
                    // Nat√ºrliches Hovering (zus√§tzliches sanftes Auf/Ab)
                    const time = Date.now() * 0.002;
                    const hoverOffset = Math.sin(time) * 0.02;
                    
                    monti.position.y = 0.2 + bobbingOffset + hoverOffset;
                }
                
                // Boost-Glow-Effekt
                if (monti.boostGlow) {
                    if (boostActive) {
                        // Pulsierender Glow
                        const time = Date.now() * 0.01;
                        monti.boostGlow.material.opacity = 0.3 + Math.sin(time) * 0.15;
                        monti.boostGlow.scale.set(1 + Math.sin(time * 0.5) * 0.1, 1 + Math.sin(time * 0.5) * 0.1, 1 + Math.sin(time * 0.5) * 0.1);
                    } else {
                        // Fade out
                        monti.boostGlow.material.opacity *= 0.95;
                        if (monti.boostGlow.material.opacity < 0.01) {
                            monti.boostGlow.material.opacity = 0;
                        }
                    }
                }
                
                // Kondensstreifen bei Boost
                if (boostActive && Math.random() > 0.5) {
                    // Erstelle Partikel
                    const particleGeom = new THREE.SphereGeometry(0.15, 8, 8);
                    const particleMat = new THREE.MeshBasicMaterial({ 
                        color: 0xFFFFFF,
                        transparent: true,
                        opacity: 0.8
                    });
                    const particle = new THREE.Mesh(particleGeom, particleMat);
                    
                    // Position hinter Monti (relativ zur Kamera)
                    const worldPos = new THREE.Vector3();
                    monti.getWorldPosition(worldPos);
                    particle.position.copy(worldPos);
                    particle.position.z += 2; // Hinter Monti
                    particle.position.x += (Math.random() - 0.5) * 0.3;
                    particle.position.y += (Math.random() - 0.5) * 0.3;
                    
                    scene.add(particle);
                    monti.trailParticles.push({ mesh: particle, life: 1.0 });
                }
                
                // Update Kondensstreifen-Partikel
                monti.trailParticles = monti.trailParticles.filter(p => {
                    p.life -= 0.02;
                    p.mesh.material.opacity = p.life * 0.8;
                    p.mesh.scale.set(1 - (1 - p.life) * 0.5, 1 - (1 - p.life) * 0.5, 1 - (1 - p.life) * 0.5);
                    
                    if (p.life <= 0) {
                        scene.remove(p.mesh);
                        return false;
                    }
                    return true;
                });

                // KEINE Kamera-Bewegung mehr - die Welt bewegt sich stattdessen!
                // altitudeDelta wird nicht mehr benutzt
            }

            // Animiere H√∂hen-Anzeige
            if (displayedAltitude !== targetAltitude) {
                const diff = targetAltitude - displayedAltitude;
                const step = diff > 0 ? 
                    Math.min(Math.abs(diff), 2) : // +10 in ~5 frames (schnell hoch)
                    -Math.min(Math.abs(diff), 10); // -50 in ~5 frames (schnell runter)
                
                displayedAltitude += step;
                
                // Wenn nah genug am Ziel, setze direkt
                if (Math.abs(targetAltitude - displayedAltitude) < 1) {
                    displayedAltitude = targetAltitude;
                }
                
                document.getElementById('altitude-value').textContent = Math.max(0, Math.round(displayedAltitude));
            }

            // Bewege Wolken basierend auf H√∂he (auch beschleunigt bei Boost)
            if (window.clouds && gameState.isPlaying) {
                const speedMultiplier = boostActive ? 3.0 : 1.0;
                const altitudeOffset = -gameState.altitude;
                // Wolken m√ºssen bei 140m altitude auf Monti-H√∂he sein
                // originalY ist ca. 20-25
                // Bei 0m: Y = 160 (hoch oben)
                // Bei 140m: Y = 20 (bei Monti)
                window.clouds.forEach((cloud, i) => {
                    // Speichere urspr√ºngliche Y wenn nicht vorhanden
                    if (cloud.userData.originalY === undefined) {
                        cloud.userData.originalY = cloud.position.y;
                    }
                    // Wolken starten 140m √ºber ihrer Original-Position
                    cloud.position.y = cloud.userData.originalY + 140 + altitudeOffset;
                    
                    // Parallax: Verschiedene Geschwindigkeiten f√ºr Tiefeneffekt (auch beschleunigt)
                    const baseSpeed = 0.05 + (i * 0.01);
                    cloud.position.z += baseSpeed * speedMultiplier;
                    if (cloud.position.z > 20) {
                        cloud.position.z = -100;
                        // Zuf√§llige neue X-Position beim Respawn
                        cloud.position.x = Math.random() * 60 - 30;
                    }
                });
            }

            // FOV-Dynamik basierend auf H√∂he
            if (gameState.isPlaying) {
                let targetFOV = 75; // Default
                
                // Boost √ºberschreibt normale FOV-Dynamik
                if (boostActive) {
                    targetFOV = 110; // Dramatischer Speed-Effekt!
                    
                    // Boost-Timer
                    boostDuration -= 0.016; // ca. 60fps
                    if (boostDuration <= 0) {
                        deactivateBoost();
                    }
                } else {
                    // Normale H√∂hen-basierte FOV
                    // 0-50m: FOV 80 (eng, dramatisch)
                    // 150-200m: FOV 70 (weit, ruhig)
                    const altitude = gameState.altitude;
                    if (altitude < 50) {
                        targetFOV = 80;
                    } else if (altitude > 150) {
                        targetFOV = 70;
                    } else {
                        // Linear interpolieren zwischen 80 und 70
                        targetFOV = 80 - ((altitude - 50) / 100) * 10;
                    }
                }
                
                // Smooth FOV Transition
                camera.fov += (targetFOV - camera.fov) * 0.1;
                camera.updateProjectionMatrix();
            }
            
            // Beschleunigungseffekt: Schnellere Landschafts-Bewegung bei Boost
            if (landscapeSegments.length > 0 && gameState.isPlaying) {
                const speedMultiplier = boostActive ? 3.0 : 1.0; // 3x schneller bei Boost
                const currentSpeed = landscapeScrollSpeed * speedMultiplier;
                
                landscapeSegments.forEach(segment => {
                    segment.position.z += currentSpeed;
                    
                    // Wenn Segment hinter Kamera, teleportiere es nach vorne
                    if (segment.position.z > 1200) { // 1200 (3 * 800 / 2)
                        segment.position.z -= 2400; // 2400 (3 * 800)
                    }
                    
                    // Bewege Landschaft basierend auf H√∂he
                    // Bei 0m: Landschaft bei Y=0 (Monti ist direkt am Boden!)
                    // Bei 200m: Landschaft bei Y=-200 (weit unten)
                    const altitudeOffset = -gameState.altitude;
                    segment.position.y = 0 + altitudeOffset;
                });
            }

            renderer.render(scene, camera);
        }

        function triggerWingFlap() {
            isFlapping = true;
            flapDuration = 0.8; // 0.8 Sekunden Fl√ºgelschlag
            wingFlapTime = 0;
        }

        function triggerFall() {
            isFalling = true;
            fallDuration = 1.0; // 1 Sekunde Fall-Animation
            fallTime = 0;
        }

        // Game Logic
        let gameInterval;
        let targetAltitude = 100; // Ziel-H√∂he f√ºr Animation
        let displayedAltitude = 100; // Angezeigte H√∂he
        let vocabTimer = null;
        let vocabTimeLeft = 15;

        function startGame() {
            gameState.isPlaying = true;
            gameState.altitude = 100;
            targetAltitude = 100;
            displayedAltitude = 100;
            gameState.score = 0;
            
            // Reset Streak & Boost
            streakCount = 0;
            boostActive = false;
            boostDuration = 0;
            updateStreakUI();
            document.getElementById('streak-counter').classList.remove('boost-active');
            
            document.getElementById('game-ui').style.display = 'block';
            document.getElementById('vocab-input').focus();
            
            updateUI();
            startVocabTimer();
            
            // Altitude decrease interval
            gameInterval = setInterval(() => {
                if (!gameState.isPaused) {
                    gameState.altitude -= 2; // 2 Meter pro Sekunde
                    targetAltitude = gameState.altitude;
                    updateUI();
                    
                    if (gameState.altitude <= 0) {
                        endGame();
                    }
                }
            }, 1000);
        }

        function startVocabTimer() {
            vocabTimeLeft = 15;
            updateTimerBar();
            
            if (vocabTimer) clearInterval(vocabTimer);
            
            vocabTimer = setInterval(() => {
                vocabTimeLeft -= 0.1;
                updateTimerBar();
                
                if (vocabTimeLeft <= 0) {
                    // Zeit abgelaufen - z√§hlt als falsche Antwort
                    clearInterval(vocabTimer);
                    handleTimeout();
                }
            }, 100);
        }

        function updateTimerBar() {
            const percentage = (vocabTimeLeft / 15) * 100;
            document.getElementById('timer-bar').style.width = percentage + '%';
        }

        function handleTimeout() {
            // Zeit abgelaufen - behandle wie falsche Antwort
            handleWrongAnswer();
        }

        function updateUI() {
            // Score wird direkt aktualisiert
            document.getElementById('score-value').textContent = gameState.score;
            // H√∂he wird animiert in animate() aktualisiert
        }

        function checkAnswer(answer) {
            const userAnswer = answer.trim();
            
            // Normalisierung (wie in display.html)
            const normalize = (text) => {
                return text
                    .toLowerCase()
                    .replace(/[.,!?;:]/g, '') // Entferne Satzzeichen
                    .replace(/\s+/g, ' ')     // Mehrfache Leerzeichen ‚Üí einfach
                    .trim();
            };
            
            let userNorm = normalize(userAnswer);
            
            // Erweitere Kontraktionen (wie in display.html)
            const normalizeContractions = (text) => {
                return text
                    .replace(/\bdon't\b/gi, 'do not')
                    .replace(/\bdoesn't\b/gi, 'does not')
                    .replace(/\bcan't\b/gi, 'cannot')
                    .replace(/\bwon't\b/gi, 'will not')
                    .replace(/\bshouldn't\b/gi, 'should not')
                    .replace(/\bwouldn't\b/gi, 'would not')
                    .replace(/\bcouldn't\b/gi, 'could not')
                    .replace(/\bisn't\b/gi, 'is not')
                    .replace(/\baren't\b/gi, 'are not')
                    .replace(/\bwasn't\b/gi, 'was not')
                    .replace(/\bweren't\b/gi, 'were not')
                    .replace(/\bhasn't\b/gi, 'has not')
                    .replace(/\bhaven't\b/gi, 'have not')
                    .replace(/\bhadn't\b/gi, 'had not')
                    .replace(/\bi'm\b/gi, 'i am')
                    .replace(/\byou're\b/gi, 'you are')
                    .replace(/\bhe's\b/gi, 'he is')
                    .replace(/\bshe's\b/gi, 'she is')
                    .replace(/\bit's\b/gi, 'it is')
                    .replace(/\bwe're\b/gi, 'we are')
                    .replace(/\bthey're\b/gi, 'they are')
                    .replace(/\bthat's\b/gi, 'that is')
                    .replace(/\bwho's\b/gi, 'who is')
                    .replace(/\bwhat's\b/gi, 'what is')
                    .replace(/\bhere's\b/gi, 'here is')
                    .replace(/\bi've\b/gi, 'i have')
                    .replace(/\byou've\b/gi, 'you have')
                    .replace(/\bwe've\b/gi, 'we have')
                    .replace(/\bthey've\b/gi, 'they have')
                    .replace(/\bi'd\b/gi, 'i would')
                    .replace(/\byou'd\b/gi, 'you would')
                    .replace(/\bhe'd\b/gi, 'he would')
                    .replace(/\bshe'd\b/gi, 'she would')
                    .replace(/\bwe'd\b/gi, 'we would')
                    .replace(/\bthey'd\b/gi, 'they would')
                    .replace(/\bi'll\b/gi, 'i will')
                    .replace(/\byou'll\b/gi, 'you will')
                    .replace(/\bhe'll\b/gi, 'he will')
                    .replace(/\bshe'll\b/gi, 'she will')
                    .replace(/\bit'll\b/gi, 'it will')
                    .replace(/\bwe'll\b/gi, 'we will')
                    .replace(/\bthey'll\b/gi, 'they will')
                    .replace(/\bthat'll\b/gi, 'that will')
                    .trim();
            };
            
            userNorm = normalizeContractions(userNorm);
            
            // Erweitere Abk√ºrzungen
            const expandAbbreviations = (text) => {
                return text
                    .replace(/\bsb\./gi, 'somebody')
                    .replace(/\bsb\b/gi, 'somebody')
                    .replace(/\bsth\./gi, 'something')
                    .replace(/\bsth\b/gi, 'something')
                    .trim();
            };
            
            userNorm = expandAbbreviations(userNorm);
            
            // Pr√ºfe alle m√∂glichen Antworten
            const correctAnswers = currentVocab.answers;
            
            for (let i = 0; i < correctAnswers.length; i++) {
                let correctAnswer = correctAnswers[i];
                let correctNorm = normalize(correctAnswer);
                correctNorm = normalizeContractions(correctNorm);
                correctNorm = expandAbbreviations(correctNorm);
                
                // Entferne Klammer-Inhalte f√ºr Vergleich
                const correctNoBrackets = correctNorm.replace(/\s*\([^)]*\)/g, '').trim();
                const userNoBrackets = userNorm;
                
                // 1. Exakte √úbereinstimmung
                if (userNoBrackets === correctNoBrackets || userNorm === correctNorm) {
                    handleCorrectAnswer();
                    return;
                }
                
                // 2. Komma-Toleranz
                const userNoCommas = userNoBrackets.replace(/,/g, '').replace(/\s+/g, ' ').trim();
                const correctNoCommas = correctNoBrackets.replace(/,/g, '').replace(/\s+/g, ' ').trim();
                
                if (userNoCommas === correctNoCommas) {
                    handleCorrectAnswer();
                    return;
                }
                
                // 3. Substring-Check (min. 4 Zeichen)
                const userNoSpaces = userNoBrackets.replace(/\s+/g, '');
                const correctNoSpaces = correctNoBrackets.replace(/\s+/g, '');
                
                if (userNoSpaces.length >= 4) {
                    if (correctNoSpaces.includes(userNoSpaces) || userNoSpaces.includes(correctNoSpaces)) {
                        handleCorrectAnswer();
                        return;
                    }
                }
                
                // 4. Verb-Pr√ºfung (to-Varianten)
                const cleanVerb = (text) => {
                    return text.toLowerCase()
                        .replace(/^\(to\)\s*/i, '')
                        .replace(/^to\s+/i, '')
                        .trim();
                };
                
                const userVerbClean = cleanVerb(userNoBrackets);
                const correctVerbClean = cleanVerb(correctNoBrackets);
                
                if (userVerbClean === correctVerbClean) {
                    handleCorrectAnswer();
                    return;
                }
            }
            
            // Alles falsch
            handleWrongAnswer();
        }
        
        function handleCorrectAnswer() {
            clearInterval(vocabTimer);
            
            // Streak erh√∂hen
            streakCount++;
            updateStreakUI();
            
            // Boost aktivieren bei 3er Streak
            if (streakCount >= STREAK_FOR_BOOST && !boostActive) {
                activateBoost();
            }
            
            const newAltitude = Math.min(gameState.altitude + 10, 200);
            gameState.altitude = newAltitude;
            targetAltitude = newAltitude;
            gameState.score += 10;
            
            triggerWingFlap();
            showPointsPopup('+10 Meter', true);
            showFeedback('Richtig! ‚úì', true);
            updateUI();
            updateHighscore();
            
            document.getElementById('vocab-input').value = '';
            selectRandomVocab();
            startVocabTimer();
        }
        
        function handleWrongAnswer() {
            clearInterval(vocabTimer);
            
            // Streak zur√ºcksetzen (Boost sch√ºtzt NICHT)
            streakCount = 0;
            updateStreakUI();
            
            // Normale Strafe, auch bei aktivem Boost
            const newAltitude = Math.max(gameState.altitude - 50, 0);
            gameState.altitude = newAltitude;
            targetAltitude = newAltitude;
            
            triggerFall();
            showPointsPopup('-50 Meter', false);
            showFeedback('Falsch! ‚úó', false);
            
            updateUI();
            
            document.getElementById('vocab-input').value = '';
            
            if (gameState.altitude <= 0) {
                setTimeout(() => {
                    endGame();
                }, 1000);
            } else {
                selectRandomVocab();
                startVocabTimer();
            }
        }
        
        function updateHighscore() {
            if (gameState.score > highscore) {
                highscore = gameState.score;
                document.getElementById('highscore-value').textContent = highscore;
                
                // Speichere in Firebase
                if (db && currentUser.userKey) {
                    db.ref('users/' + currentUser.userKey + '/montiGameHighscore').set(highscore)
                        .then(() => console.log('‚úì Neuer Highscore gespeichert:', highscore))
                        .catch(error => console.error('Fehler beim Speichern des Highscores:', error));
                }
            }
        }
        
        function updateStreakUI() {
            document.getElementById('streak-value').textContent = streakCount;
        }
        
        function activateBoost() {
            boostActive = true;
            boostDuration = BOOST_TIME;
            
            // UI Update
            const streakCounter = document.getElementById('streak-counter');
            streakCounter.classList.add('boost-active');
            
            // Gro√ües Boost-Popup
            showPointsPopup('üöÄ TURBO! üöÄ', true);
            showFeedback('2 Sekunden Beschleunigung!', true);
            
            console.log('üöÄ TURBO AKTIVIERT!');
        }
        
        function deactivateBoost() {
            boostActive = false;
            boostDuration = 0;
            streakCount = 0;
            
            // UI Update
            const streakCounter = document.getElementById('streak-counter');
            streakCounter.classList.remove('boost-active');
            updateStreakUI();
            
            console.log('Boost abgelaufen');
        }

        function showPointsPopup(text, isPositive) {
            const popup = document.createElement('div');
            popup.textContent = text;
            popup.style.position = 'absolute';
            
            // Zuf√§llige Position um Monti herum (45-55% horizontal, 35-45% vertikal)
            const randomX = 45 + Math.random() * 10; // 45-55%
            const randomY = 35 + Math.random() * 10; // 35-45%
            
            popup.style.left = randomX + '%';
            popup.style.top = randomY + '%';
            popup.style.transform = 'translate(-50%, -50%)';
            popup.style.fontSize = '48px';
            popup.style.fontWeight = 'bold';
            popup.style.color = isPositive ? '#00FF00' : '#FF0000';
            popup.style.textShadow = '3px 3px 0px rgba(0, 0, 0, 0.5)';
            popup.style.pointerEvents = 'none';
            popup.style.zIndex = '1000';
            popup.style.animation = 'popupBurst 0.8s ease-out forwards';
            
            document.getElementById('ui-overlay').appendChild(popup);
            
            // Remove after animation
            setTimeout(() => {
                popup.remove();
            }, 800);
        }

        // CSS f√ºr popup animation wird im style-tag hinzugef√ºgt

        function showFeedback(text, isCorrect) {
            const feedback = document.getElementById('feedback');
            feedback.textContent = text;
            feedback.className = isCorrect ? 'correct' : 'wrong';
            feedback.style.display = 'block';
            
            setTimeout(() => {
                feedback.style.display = 'none';
            }, 1000);
        }

        function endGame() {
            clearInterval(gameInterval);
            clearInterval(vocabTimer);
            gameState.isPlaying = false;
            
            document.getElementById('final-score-value').textContent = gameState.score;
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        // Event Listeners
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const introScreen = document.getElementById('intro-screen');
                if (introScreen.style.display !== 'none') {
                    // Start countdown
                    introScreen.style.display = 'none';
                    startCountdown();
                } else if (gameState.isPlaying) {
                    // Check answer
                    const input = document.getElementById('vocab-input');
                    if (input.value.trim()) {
                        checkAnswer(input.value);
                    }
                }
            }
        });

        function startCountdown() {
            const countdownScreen = document.getElementById('countdown-screen');
            const countdownNumber = document.getElementById('countdown-number');
            
            countdownScreen.style.display = 'flex';
            
            let count = 3;
            countdownNumber.textContent = count;
            
            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownNumber.textContent = count;
                    // Trigger animation restart
                    countdownNumber.style.animation = 'none';
                    setTimeout(() => {
                        countdownNumber.style.animation = 'countdownPop 0.5s ease-out';
                    }, 10);
                } else {
                    countdownNumber.textContent = 'GO!';
                    countdownNumber.style.animation = 'none';
                    setTimeout(() => {
                        countdownNumber.style.animation = 'countdownPop 0.5s ease-out';
                    }, 10);
                    
                    setTimeout(() => {
                        countdownScreen.style.display = 'none';
                        startGame();
                    }, 800);
                    
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }

        // Initialize
        async function init() {
            initFirebase(); // Firebase zuerst
            const success = await loadUserAndVocabs();
            if (success) {
                selectRandomVocab(); // Setze erste Vokabel
                initThreeJS();
                animate();
            }
        }
        
        init();
    </script>
</body>
</html>
